#!/usr/bin/env python
# coding: utf-8

# Import Libraries

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sb


#Read Input File
appdata=pd.read_csv('./Data/application_data.csv')

#Check Categorical Column Values

appdata['NAME_CONTRACT_TYPE'].isna().sum()
appdata['NAME_CONTRACT_TYPE'].value_counts()

#Contract Type has two values i.e. two types of loans. making this categorical valriable into two boolean indicator.
appdata['CASH_LOAN']=appdata['NAME_CONTRACT_TYPE'].apply(lambda x:1 if x=='Cash loans' else 0)
appdata['REVOLVING_LOAN']=appdata['NAME_CONTRACT_TYPE'].apply(lambda x:1 if x=='Revolving loans' else 0)

#Gender has two values making this categorical valriable into two boolean indicator.
appdata['MALE']=appdata['CODE_GENDER'].apply(lambda x:1 if x=='M' else 0)
appdata['FEMALE']=appdata['CODE_GENDER'].apply(lambda x:1 if x in ('F','XNA') else 0)

#Owning a car has two values making this categorical valriable into two boolean indicator.
df['Owns_Car']=df['FLAG_OWN_CAR'].apply(lambda x:1 if x=='Y' else 0)
df['Doesnt_Own_Car']=df['FLAG_OWN_CAR'].apply(lambda x:1 if x=='N' else 0)

#Education type was grouped into two values making this categorical variable into two boolean indicator.
df['College_Education']=df['NAME_EDUCATION_TYPE'].apply(lambda x:1 if x in ('Academic degree','Higher education') else 0)
df['Less_Than_College_Education']=df['NAME_EDUCATION_TYPE'].apply(lambda x:1 if x in ('Incomplete higher','Lower secondary', 'Secondary / secondary special') else 0)

#Name type suite was grouped into two values making this categorical variable into two boolean indicator.
df['Unaccompanied']=df['NAME_TYPE_SUITE'].fillna('MISSING')
df['Accompanied']=df['NAME_TYPE_SUITE'].apply(lambda x:1 if x in ('Children','Family','Group of people','Spouse, partner') else 0)
df['Unaccompanied']=df['NAME_TYPE_SUITE'].apply(lambda x:1 if x in ('Other_A','Other_B','Unaccompanied','MISSING') else 0)

#Name income type was grouped into two values making this categorical variable into two boolean indicator.
df['Workforce']=df['NAME_INCOME_TYPE'].apply(lambda x:1 if x in ('Businessman','Commercial associate','State servant','Working') else 0)
df['NonWorkforce']=df['NAME_INCOME_TYPE'].apply(lambda x:1 if x in ('Maternity leave','Pensioner','Student','Unemployed') else 0)

#Housing type was grouped into two values making this categorical variable into two boolean indicator.
df['Own Apt']=df['NAME_HOUSING_TYPE'].apply(lambda x:1 if x in ('Co-op apartment','House / apartment','Municipal apartment','Office apartment') else 0)
df['Does Not Own Apt']=df['NAME_HOUSING_TYPE'].apply(lambda x:1 if x in ('Rented apartment','With parents') else 0)

#Weekday application process was grouped into two values making this categorical variable into two boolean indicator.
df['T_W_TH_F_APP']=df['WEEKDAY_APPR_PROCESS_START'].apply(lambda x:1 if x in ('TUESDAY','WEDNESDAY','THURSDAY','FRIDAY') else 0)
df['SAT_SUN_MON_APP']=df['WEEKDAY_APPR_PROCESS_START'].apply(lambda x:1 if x in ('SATURDAY','SUNDAY','MONDAY') else 0)

#Family Status Categorical Variable. Converting it to numerical values by weighted average with the similar categories
category1 = ['Civil marriage','Single / not married']
category2 = ['Married','Widow']
category3 = ['Separated','Unkown']

def Family_Status(df):
    if df['NAME_FAMILY_STATUS'] in category1:
        return 0.0986
    elif df['NAME_FAMILY_STATUS'] in category2:
        return 0.0743
    elif df['NAME_FAMILY_STATUS'] in category3:
        return 0.0819
    else:
        return 0.0819
    
df['NAME_FAMILY_STATUS']=df.apply(Family_Status,axis=1)

#Occupation Type Categorical Variable. Converting it to numerical values by weighted average with the similar categories
#Occupation Type Categorical Variable. Converting it to numerical values by weighted average with the similar categories
highSkilled = ['Core staff','High skill tech staff','HR staff','IT staff','Accountants','Managers','Medicine staff','Private service staff',
            'Realty agents','Secretaries']
losSkilled = ['Drivers','Low-skill Laborers','Security staff','Waiters/barmen staff','Laborers','Cleaning staff',
              'Cooking staff','Sales staff']

appdata['HIGH_SKILLED']=appdata['OCCUPATION_TYPE'].apply(lambda x:1 if x in highSkilled else 0)
appdata['LOW_SKILLED']=appdata['OCCUPATION_TYPE'].apply(lambda x:1 if x in lowSkilled else 0)

#Organization Type Categorical Variable. Converting it to numerical values by weighted average with the similar categories
category1 = ['Business Entity Type 1','Business Entity Type 2','Business Entity Type 3','Postal','Security','Mobile',
             'Advertising']
category2 = ['Self-employed','Agriculture','Cleaning','Construction','Realtor','Restaurant','Transport: type 3',
             'Transport: type 4']
category3 = ['Transport: type 1','Transport: type 2','XNA','Other','University','Telecom','Services','Security Ministries',
            'School','Religion','Police','Military','Medicine','Legal Services','Kindergarten','Insurance','Culture',
            'Electricity','Emergency','Government','Hotel','Housing','Bank']
category4 = ['Trade: type 7','Trade: type 3','Industry: type 9','Industry: type 3','Industry: type 11','Trade: type 2',
             'Industry: type 7','Industry: type 1','Industry: type 4','Trade: type 6','Industry: type 5','Industry: type 2',
             'Industry: type 12','Trade: type 1','Industry: type 6','Industry: type 10','Industry: type 13','Trade: type 4',
             'Trade: type 5','Industry: type 8']

def org_type_norm(appdata):
    if appdata['ORGANIZATION_TYPE'] in category1:
        return 0.0913
    elif appdata['ORGANIZATION_TYPE'] in category2:
        return 0.1045
    elif appdata['ORGANIZATION_TYPE'] in category3:
        return 0.0615
    elif appdata['ORGANIZATION_TYPE'] in category4:
        return 0.0884
    else:
        return 0.0
    
appdata['ORG_TYPE_NUM']=appdata.apply(org_type_norm,axis=1)

#Fill the NULL vaalues with string MISSING for computation.
appdata['FONDKAPREMONT_MODE']=appdata['FONDKAPREMONT_MODE'].fillna('MISSING')

#Create a new dummy variable to represent data present or not. 1= present, 0=missing
appdata['FONDKAPREMONT_MODE_PRESENT'] = appdata['FONDKAPREMONT_MODE'].apply(lambda x:0 if x in ('MISSING','not specified') else 1)

#Fill the NULL vaalues with string MISSING for computation.
appdata['HOUSETYPE_MODE']=appdata['HOUSETYPE_MODE'].fillna('MISSING')

#Create a new dummy variable to represent data present or not. 1= block of flats, 0=missing
appdata['HOUSETYPE_MODE_PRESENT'] = appdata['HOUSETYPE_MODE'].apply(lambda x:1 if x == 'block of flats' else 0)

#Wall Materials Categorical Variable. Converting it to numerical values by weighted average with the similar categories
category1 = ['Panel','Monolithic']
category2 = ['Stone, brick','Block','Mixed','Others']
category3 = ['Wooden','Blank']

def wall_material(appdata):
    if appdata['WALLSMATERIAL_MODE'] in category1:
        return 0.0631
    elif appdata['WALLSMATERIAL_MODE'] in category2:
        return 0.0738
    elif appdata['WALLSMATERIAL_MODE'] in category3:
        return 0.0915
    else:
        return 0.0915
    
appdata['WALLSMATERIAL_MODE_NUM']=appdata.apply(wall_material,axis=1)

#Fill the NULL vaalues with string MISSING for computation.
appdata['EMERGENCYSTATE_MODE']=appdata['EMERGENCYSTATE_MODE'].fillna('MISSING')

#Create a new dummy variable to represent data present or not. 1= present, 0=missing
appdata['EMERGENCYSTATE_MODE_PRESENT'] = appdata['EMERGENCYSTATE_MODE'].apply(lambda x:0 if x == 'MISSING' else 1)

#Create Dummy Variable for highly missing features. 1 - Data Present 0 - Data Missing. Replace missing values with mean.
featureList = ['COMMONAREA_AVG','COMMONAREA_MODE','COMMONAREA_MEDI','NONLIVINGAPARTMENTS_AVG','NONLIVINGAPARTMENTS_MODE',
               'NONLIVINGAPARTMENTS_MEDI','LIVINGAPARTMENTS_AVG','LIVINGAPARTMENTS_MODE',
               'LIVINGAPARTMENTS_MEDI','FLOORSMIN_AVG','FLOORSMIN_MODE','FLOORSMIN_MEDI','YEARS_BUILD_AVG','YEARS_BUILD_MODE',
               'YEARS_BUILD_MEDI','OWN_CAR_AGE','LANDAREA_AVG','LANDAREA_MODE','LANDAREA_MEDI','BASEMENTAREA_AVG',
               'BASEMENTAREA_MODE','BASEMENTAREA_MEDI','EXT_SOURCE_1','NONLIVINGAREA_AVG','NONLIVINGAREA_MODE',
               'NONLIVINGAREA_MEDI','ELEVATORS_AVG','ELEVATORS_MODE','ELEVATORS_MEDI','APARTMENTS_AVG',
               'APARTMENTS_MODE','APARTMENTS_MEDI','ENTRANCES_AVG','ENTRANCES_MODE','ENTRANCES_MEDI','LIVINGAREA_AVG',
               'LIVINGAREA_MODE','LIVINGAREA_MEDI','FLOORSMAX_AVG','FLOORSMAX_MODE','FLOORSMAX_MEDI',
               'YEARS_BEGINEXPLUATATION_AVG','YEARS_BEGINEXPLUATATION_MODE','YEARS_BEGINEXPLUATATION_MEDI','TOTALAREA_MODE',
               'EXT_SOURCE_3','AMT_REQ_CREDIT_BUREAU_HOUR','AMT_REQ_CREDIT_BUREAU_DAY','AMT_REQ_CREDIT_BUREAU_WEEK',
               'AMT_REQ_CREDIT_BUREAU_MON','AMT_REQ_CREDIT_BUREAU_QRT','AMT_REQ_CREDIT_BUREAU_YEAR','OBS_30_CNT_SOCIAL_CIRCLE',
               'DEF_30_CNT_SOCIAL_CIRCLE','OBS_60_CNT_SOCIAL_CIRCLE','DEF_60_CNT_SOCIAL_CIRCLE','EXT_SOURCE_2',
               'AMT_GOODS_PRICE']

for column in featureList:
    meanValue = appdata[column].mean()
#    print(column+' mean ',meanValue)
#    print('Number of Rows Missing Value ',appdata[column].isna().sum())
    appdata[column].fillna('MISSING',inplace=True)
    appdata[column+'_NORM'] = appdata[column].apply(lambda x:0 if x == 'MISSING' else 1)
    appdata[column] = appdata[column].apply(lambda x:meanValue if x == 'MISSING' else x)
#    print(appdata[column+'_NORM'].value_counts())

#Drop Categorical Columns
categoricalcolumns = ['NAME_CONTRACT_TYPE','CODE_GENDER','OCCUPATION_TYPE','ORGANIZATION_TYPE','FONDKAPREMONT_MODE',
                      'HOUSETYPE_MODE','WALLSMATERIAL_MODE','EMERGENCYSTATE_MODE']

#drop categorical columns from the dataset
for name in categoricalcolumns:
    appdata=appdata.drop(columns=name)


appdata.head()

#Investigate the entire dataset about default and regular loans
for name in appdata.columns:
    if appdata[name].isna().sum() > 0:
        percent = round(((appdata[name].isna().sum())/(appdata[name].count()+appdata[name].isna().sum()))*100,2)
        if percent > 0.00:
            print(name+','+str(appdata[name].isna().sum())+','+str(percent)+'%')

#Number of People Defaulted on Loan v/s Total Population
print('Number of Applicant with payment default: ',appdata['TARGET'].sum())
print('Proportion of Applicant with payment default: ',round((appdata['TARGET'].sum()/len(appdata))*100,2),'%')

#Relationship with Contract Type and Load Default
#sb.countplot(x='NAME_CONTRACT_TYPE',data=appdata[appdata['TARGET']==1])
df=appdata[appdata['TARGET']==1]
print('Proportion of Applicant default for Cash Loan : ',round((df['CASH_LOAN'].sum()/len(appdata[appdata['CASH_LOAN']==1]))*100,2),'%')
print('Proportion of Applicant default for Revolving Loan : ',round((df['REVOLVING_LOAN'].sum()/len(appdata[appdata['REVOLVING_LOAN']==1]))*100,2),'%')


#print(appdata['OCCUPATION_TYPE'].isna().sum())
print(appdata['WALLSMATERIAL_MODE'].value_counts())
#print(df['OCCUPATION_TYPE'].value_counts())

#Split Files to make default v/s non-default 1:2 ratio
df1=appdata[appdata['TARGET']==1]
df2=appdata[appdata['TARGET']==0].sample(frac=0.2,random_state=0)
frames=[df1,df2]
dfNew = pd.concat(frames)

#lasso regression- this code assumes the logistic regression model has already been setup as well as the train_test_split function - included below as reference
#noobs = 1000000
#predictors = []
#for column in appdata.columns:
    #if column != 'TARGET':
        predictors.append(column)
    #X = appdata[predictors].head(noobs)
    #y = appdata['TARGET'].head(noobs)
#from sklearn.model_selection import train_test_split
#X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.3,random_state=31)

from sklearn.linear_model import Lasso
lasso51 = Lasso(alpha=51, max_iter=1000000)
lasso51.fit(X_train,y_train)
coeff_used51 = np.sum(lasso51.coef_!=0)
print("number of features used: for alpha =0.51:", coeff_used51)
print(lasso10.coef_)
